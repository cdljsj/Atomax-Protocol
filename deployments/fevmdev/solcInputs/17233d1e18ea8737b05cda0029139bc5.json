{
  "language": "Solidity",
  "sources": {
    "contracts/CommonJumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./Interfaces/InterestRateModel.sol\";\n\n/**\n  * @title Logic for Compound's JumpRateModel Contract V2.\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n  */\ncontract CommonJumpRateModel is InterestRateModel {\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\n\n    uint256 private constant BASE = 1e18;\n\n    /**\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n    address public owner;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n    constructor(uint blocksPerYear_, uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) {\n        owner = owner_;\n        blocksPerYear = blocksPerYear_;\n        updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) virtual external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows * BASE / (cash + borrows - reserves);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n        } else {\n            uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n            uint excessUtil = util - kink;\n            return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n        }\n    }\n\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual override external view returns (uint) {\n        return getBorrowRateInternal(cash, borrows, reserves);\n    }\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) {\n        uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\n        return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\n        multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}\n"
    },
    "contracts/Fevm/MockWFIL.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract MockWFIL {\n  string public name = 'Wrapped FIL';\n  string public symbol = 'WFIL';\n  uint8 public decimals = 18;\n\n  event Approval(address indexed src, address indexed guy, uint wad);\n  event Transfer(address indexed src, address indexed dst, uint wad);\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n\n  mapping(address => uint) public balanceOf;\n  mapping(address => mapping(address => uint)) public allowance;\n\n  receive() external payable {\n    deposit();\n  }\n\n  function deposit() public payable {\n    balanceOf[msg.sender] += msg.value;\n    emit Deposit(msg.sender, msg.value);\n  }\n\n  function withdraw(uint wad) public {\n    require(balanceOf[msg.sender] >= wad);\n    balanceOf[msg.sender] -= wad;\n    payable(msg.sender).transfer(wad);\n    emit Withdrawal(msg.sender, wad);\n  }\n\n  function totalSupply() public view returns (uint) {\n    return address(this).balance;\n  }\n\n  function approve(address guy, uint wad) public returns (bool) {\n    allowance[msg.sender][guy] = wad;\n    emit Approval(msg.sender, guy, wad);\n    return true;\n  }\n\n  function transfer(address dst, uint wad) public returns (bool) {\n    return transferFrom(msg.sender, dst, wad);\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint wad\n  ) public returns (bool) {\n    require(balanceOf[src] >= wad);\n\n    if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n      require(allowance[src][msg.sender] >= wad);\n      allowance[src][msg.sender] -= wad;\n    }\n\n    balanceOf[src] -= wad;\n    balanceOf[dst] += wad;\n\n    emit Transfer(src, dst, wad);\n\n    return true;\n  }\n}\n"
    },
    "contracts/Interfaces/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\nabstract contract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}