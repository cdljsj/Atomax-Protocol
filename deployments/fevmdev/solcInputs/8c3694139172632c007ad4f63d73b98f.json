{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Interfaces/PriceOracle.sol\";\nimport \"./Interfaces/ComptrollerInterface.sol\";\nimport \"./Interfaces/ISmartAccount.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./FixedMath.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract Comptroller is ComptrollerStorage, ComptrollerInterface, ComptrollerErrorReporter {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewMarketLiquidationIncentive(address cToken, uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPausedGlobally(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    // /// @notice Emitted when a new borrow-side COMP speed is calculated for a market\n    // event CompBorrowSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    // /// @notice Emitted when a new supply-side COMP speed is calculated for a market\n    // event CompSupplySpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    // /// @notice Emitted when COMP is distributed to a supplier\n    // event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    // /// @notice Emitted when COMP is distributed to a borrower\n    // event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    // event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    /// @notice Emitted when COMP accrued for a user has been manually adjusted.\n    // event CompAccruedAdjusted(address indexed user, uint oldCompAccrued, uint newCompAccrued);\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint internal constant collateralFactorMaxMantissa = 0.98e18; // 0.98\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     */\n    function enterMarkets(address[] memory cTokens) override external {\n        uint len = cTokens.length;\n\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n            addToMarketInternal(cToken, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) revert MarketNotListed();\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        emit MarketEntered(cToken, borrower);\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     */\n    function exitMarket(address cTokenAddress) override external {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) revert ExitMarketBalanceOwned();\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) revert ExitMarketFailed(allowed);\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return;\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(cToken, msg.sender);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cToken, \n                         address, // minter The account which would get the minted tokens\n                         uint     // mintAmount The amount of underlying being supplied to the market in exchange for tokens\n                         ) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        if (mintGuardianPaused[cToken]) revert MintPaused();\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        // distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        // distributeSupplierComp(cToken, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override pure external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert RedeemTokensZero();\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        if (borrowGuardianPaused[cToken]) revert BorrowPaused();\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            if (msg.sender != cToken) revert SenderNotCToken();\n\n            // attempt to add borrower to the market\n            addToMarketInternal(CToken(msg.sender), borrower);\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        uint borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            uint nextTotalBorrows = FixedMath.add_(totalBorrows, borrowAmount);\n            if (nextTotalBorrows >= borrowCap) revert BorrowCapReached();\n        }\n\n        (Error err2, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n        if (err2 != Error.NO_ERROR) {\n            return uint(err2);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        FixedMath.Exp borrowIndex = FixedMath.Exp.wrap(CToken(cToken).borrowIndex());\n        updateCompBorrowIndex(cToken, borrowIndex);\n        // distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) override external returns (uint) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        FixedMath.Exp borrowIndex = FixedMath.Exp.wrap(CToken(cToken).borrowIndex());\n        updateCompBorrowIndex(cToken, borrowIndex);\n        // distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) override view external returns (uint) {\n        // Shh - currently unused\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            if (borrowBalance < repayAmount) revert RepayTooMuch();\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (uint err, , uint shortfall) = getAccountLiquidity(borrower);\n            if (err != 0) {\n                return err;\n            }\n\n            if (shortfall == 0) {\n                return uint(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint maxClose = FixedMath.mul_ScalarTruncate(FixedMath.Exp.wrap(closeFactorMantissa), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        if (seizeGuardianPaused) revert SeizePaused();\n\n        // Shh - currently unused\n        seizeTokens;\n        liquidator;\n        borrower;\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cTokenCollateral);\n        // distributeSupplierComp(cTokenCollateral, borrower);\n        // distributeSupplierComp(cTokenCollateral, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        if (transferGuardianPaused) revert TransferPaused();\n\n        dst;\n        \n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        // distributeSupplierComp(cToken, src);\n        // distributeSupplierComp(cToken, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        FixedMath.Exp collateralFactor;\n        FixedMath.Exp exchangeRate;\n        FixedMath.Exp oraclePrice;\n        FixedMath.Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n        // (Error err, uint liquidity, uint shortfall) = getAccountLiquidityInternal(account);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    // function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n    //     return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n    // }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        // uint oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (,vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n           \n            vars.collateralFactor = FixedMath.Exp.wrap(markets[address(asset)].liquidateCollateralFactorMantissa);\n            vars.exchangeRate = FixedMath.Exp.wrap(vars.exchangeRateMantissa);\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = FixedMath.Exp.wrap(vars.oraclePriceMantissa);\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = FixedMath.mul_(FixedMath.mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = FixedMath.mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = FixedMath.mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = FixedMath.mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = FixedMath.mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        if (smartAccountFactory.isValidSmartAccount(account)) {\n            uint extraCollateral = ISmartAccount(account).getNonStandardCollateralAssetValue();\n            vars.sumCollateral = vars.sumCollateral + extraCollateral;\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) revert PriceError();\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        FixedMath.Exp numerator;\n        FixedMath.Exp denominator;\n        FixedMath.Exp ratio;\n\n        uint liquidationIncentive = markets[cTokenCollateral].liquidationIncentiveMantissa;\n        numerator = FixedMath.mul_(FixedMath.Exp.wrap(liquidationIncentive), FixedMath.Exp.wrap(priceBorrowedMantissa));\n        denominator = FixedMath.mul_(FixedMath.Exp.wrap(priceCollateralMantissa), FixedMath.Exp.wrap(exchangeRateMantissa));\n        ratio = FixedMath.mul_(numerator, denominator);\n\n        seizeTokens = FixedMath.mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) revert Unauthorized();\n\n      // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oracle, newOracle);\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure\n      */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) revert Unauthorized();\n        \n        emit NewCloseFactor(closeFactorMantissa, newCloseFactorMantissa);\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa, uint liquidateCollateralFactorExtra) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) revert Unauthorized();\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) revert MarketNotListed();\n\n        if (newCollateralFactorMantissa > collateralFactorMaxMantissa) revert InvalidCollaternalFactor();\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) revert PriceError();\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, market.collateralFactorMantissa, newCollateralFactorMantissa);\n    \n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n        uint newLiquidateCollateralFactorMantissa = newCollateralFactorMantissa + liquidateCollateralFactorExtra;\n        if (newLiquidateCollateralFactorMantissa > FixedMath.mantissaOne) {\n            newLiquidateCollateralFactorMantissa = FixedMath.mantissaOne;\n        }\n        market.liquidateCollateralFactorMantissa = newLiquidateCollateralFactorMantissa;\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    /**\n      * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa, address cToken) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) revert Unauthorized();\n\n        if (cToken != address(0)) {\n            // Verify market is listed\n            Market storage market = markets[cToken];\n            if (!market.isListed) revert MarketNotListed();\n\n            emit NewMarketLiquidationIncentive(cToken, liquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n            market.liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n            return uint(Error.NO_ERROR);\n        }\n        \n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(liquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) revert Unauthorized();\n\n        if (markets[address(cToken)].isListed) revert MarketAlreadyListed();\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        // Note that isComped is not in active use anymore\n        Market storage newMarket = markets[address(cToken)];\n        newMarket.isListed = true;\n        newMarket.collateralFactorMantissa = 0;\n        newMarket.liquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        _addMarketInternal(address(cToken));\n        // _initializeMarket(address(cToken));\n\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _addMarketInternal(address cToken) internal {\n        for (uint i = 0; i < allMarkets.length; i ++) {\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\n        }\n        allMarkets.push(CToken(cToken));\n    }\n\n    // function _initializeMarket(address cToken) internal {\n    //     uint32 blockNumber = uint32(getBlockNumber());\n\n    //     CompMarketState storage supplyState = compSupplyState[cToken];\n    //     CompMarketState storage borrowState = compBorrowState[cToken];\n\n    //     /*\n    //      * Update market state indices\n    //      */\n    //     if (supplyState.index == 0) {\n    //         // Initialize supply state index with default value\n    //         supplyState.index = compInitialIndex;\n    //     }\n\n    //     if (borrowState.index == 0) {\n    //         // Initialize borrow state index with default value\n    //         borrowState.index = compInitialIndex;\n    //     }\n\n    //     /*\n    //      * Update market state block numbers\n    //      */\n    //      supplyState.block = borrowState.block = blockNumber;\n    // }\n\n\n    /**\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n        if (msg.sender != admin) revert Unauthorized();\n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     */\n    function _setPauseGuardian(address newPauseGuardian) external {\n        if (msg.sender != admin) revert Unauthorized();\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(pauseGuardian, newPauseGuardian);\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        if (!markets[address(cToken)].isListed) revert MarketNotListed();\n        checkPermission(state);\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        if (!markets[address(cToken)].isListed) revert MarketNotListed();\n        checkPermission(state);\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        checkPermission(state);\n        transferGuardianPaused = state;\n        emit ActionPausedGlobally(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) external returns (bool) {\n        checkPermission(state);\n        seizeGuardianPaused = state;\n        emit ActionPausedGlobally(\"Seize\", state);\n        return state;\n    }\n\n    function _setRewardsPool(RewardsPool rewardsPool_) external {\n        if (msg.sender != admin) revert Unauthorized();\n        rewardsPool = rewardsPool_;\n    }\n\n    function checkPermission(bool state) private view {\n        if (msg.sender != pauseGuardian && msg.sender != admin) revert Unauthorized();\n        if (msg.sender != admin && state != true) revert Unauthorized();\n    }\n\n    function _become(Unitroller unitroller) external {\n        if (msg.sender!= unitroller.admin()) revert Unauthorized();\n        if (unitroller._acceptImplementation() != 0) revert Unauthorized();\n    }\n\n    /**\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\n     */\n    function adminOrInitializing() internal view returns (bool) {\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n    function updateCompSupplyIndex(address cToken) public {\n        if (address(rewardsPool) != address(0)) {\n            rewardsPool.updateRewardsSupplyIndex(cToken);\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n    function updateCompBorrowIndex(address cToken, FixedMath.Exp marketBorrowIndex) public {\n        if (address(rewardsPool) != address(0)) {\n            rewardsPool.updateRewardsBorrowIndex(cToken, marketBorrowIndex);\n        }\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) internal view returns (bool) {\n        return\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\n            borrowGuardianPaused[address(cToken)] == true &&\n            cToken.reserveFactorMantissa() == 1e18\n        ;\n    }\n\n    function getBlockNumber() virtual public view returns (uint) {\n        return block.number;\n    }\n\n    function isValidSmartAccount(address account) virtual external override returns (bool) {\n        return smartAccountFactory.isValidSmartAccount(account);\n    }\n}\n"
    },
    "contracts/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./Interfaces/PriceOracle.sol\";\nimport \"./Interfaces/ISmartAccountFactory.sol\";\nimport \"./RewardsPool.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerStorage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n\n        //  Multiplier representing the most one can borrow against their collateral in this market.\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\n        //  Must be between 0 and 1, and stored as a mantissa.\n        uint collateralFactorMantissa;\n\n        uint liquidateCollateralFactorMantissa;\n\n        uint liquidationIncentiveMantissa;\n\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n\n    ISmartAccountFactory public smartAccountFactory;\n    \n    RewardsPool public rewardsPool;\n}\n"
    },
    "contracts/CToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./Interfaces/ComptrollerInterface.sol\";\nimport \"./Interfaces/CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Interfaces/EIP20Interface.sol\";\nimport \"./Interfaces/InterestRateModel.sol\";\nimport \"./Interfaces/ISmartAccountFactory.sol\";\nimport \"./Interfaces/ISmartAccount.sol\";\nimport \"./FixedMath.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        if (msg.sender != admin) revert Unauthorized();\n        if (accrualBlockNumber != 0 || borrowIndex != 0) revert MarketAlreadyInitialized();\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        if (initialExchangeRateMantissa == 0) revert InitialExchangeRateCannotBeZero();\n\n        // Set the comptroller\n        _setComptroller(comptroller_);\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = FixedMath.mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        _setInterestRateModelFresh(interestRateModel_);\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return 0 if the transfer succeeded, else revert\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            revert TransferComptrollerRejection(allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            revert TransferNotAllowed();\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = accountTokens[src] - tokens;\n        accountTokens[dst] = accountTokens[dst] + tokens;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint).max) {\n            transferAllowances[src][spender] = startingAllowance - tokens;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        FixedMath.Exp exchangeRate = FixedMath.Exp.wrap(exchangeRateCurrent());\n        return FixedMath.mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        return (\n            NO_ERROR,\n            accountTokens[account],\n            borrowBalanceStoredInternal(account),\n            exchangeRateStoredInternal()\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() virtual internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n        accrueInterest();\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        return borrowBalanceStoredInternal(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            uint exchangeRate = cashPlusBorrowsMinusReserves * FixedMath.expScale / _totalSupply;\n\n            return exchangeRate;\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() virtual override public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        if (borrowRateMantissa > borrowRateMaxMantissa) revert BorrowRateTooHigh();\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n        accrualBlockNumber = currentBlockNumber;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrows = interestAccumulated + totalBorrows\n         *  totalReserves = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndex = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        FixedMath.Exp simpleInterestFactor = FixedMath.mul_(FixedMath.Exp.wrap(borrowRateMantissa), blockDelta);\n        uint interestAccumulated = FixedMath.mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        totalBorrows = interestAccumulated + borrowsPrior;\n        totalReserves = FixedMath.mul_ScalarTruncateAddUInt(FixedMath.Exp.wrap(reserveFactorMantissa), interestAccumulated, reservesPrior);\n        borrowIndex = FixedMath.mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndex, totalBorrows);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            revert MintComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert MintFreshnessCheck();\n        }\n\n        FixedMath.Exp exchangeRate = FixedMath.Exp.wrap(exchangeRateStoredInternal());\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint mintTokens = FixedMath.div_(actualMintAmount, exchangeRate);\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, actualMintAmount, mintTokens);\n        emit Transfer(address(this), minter, mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\n        if (redeemTokensIn != 0 && redeemAmountIn != 0) revert RedeemTokensInOrRedeemAmountInShouldBeZero();\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        FixedMath.Exp exchangeRate = FixedMath.Exp.wrap(exchangeRateStoredInternal());\n\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = FixedMath.mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = FixedMath.div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n        if (allowed != 0) {\n            revert RedeemComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RedeemFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < redeemAmount) {\n            revert RedeemTransferOutNotPossible();\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, redeemAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(msg.sender), borrowAmount);\n    }\n\n    /**\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowFresh(address payable borrower, uint borrowAmount) internal {\n        /* Fail if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            revert BorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert BorrowFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            revert BorrowCashNotAvailable();\n        }\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowNew = accountBorrow + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n     * @return (uint) the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            revert RepayBorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RepayBorrowFreshnessCheck();\n        }\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n        return actualRepayAmount;\n    }\n\n    function repayWithDeposit(address borrower, uint repayAmount) external {\n        accrueInterest();\n        address repayer = msg.sender;\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), repayer, borrower, repayAmount);\n        if (allowed != 0) {\n            revert RepayBorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RepayBorrowFreshnessCheck();\n        }\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        FixedMath.Exp exchangeRate = FixedMath.Exp.wrap(exchangeRateStoredInternal());\n\n        uint redeemTokens = FixedMath.div_(repayAmountFinal, exchangeRate);\n\n        if (repayer != borrower) {\n            allowed = comptroller.redeemAllowed(address(this), repayer, redeemTokens);\n            if (allowed != 0) {\n                revert RedeemComptrollerRejection(allowed);\n            }\n        }\n       \n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[repayer] = accountTokens[repayer] - redeemTokens;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint accountBorrowsNew = accountBorrowsPrev - repayAmountFinal;\n        uint totalBorrowsNew = totalBorrows - repayAmountFinal;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(repayer, address(this), redeemTokens);        \n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(repayer, borrower, repayAmountFinal, accountBorrowsNew, totalBorrowsNew);\n\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\n        accrueInterest();\n\n        uint error = cTokenCollateral.accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            revert LiquidateAccrueCollateralInterestFailed(error);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            revert LiquidateComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert LiquidateFreshnessCheck();\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            revert LiquidateCollateralFreshnessCheck();\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            revert LiquidateLiquidatorIsBorrower();\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            revert LiquidateCloseAmountIsZero();\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == type(uint).max) {\n            revert LiquidateCloseAmountIsUintMax();\n        }\n\n        /* Fail if repayBorrow fails */\n        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n\n        if (comptroller.isValidSmartAccount(borrower)) {\n            ISmartAccount smartBorrower = ISmartAccount(borrower);\n            uint accountCollateralValue = smartBorrower.getNonStandardCollateralAssetValue();\n            if (accountCollateralValue < seizeTokens) revert LiquidateSizeTooMuch();\n            smartBorrower.liquidate(borrower, liquidator);\n            return;\n        }\n        /* Revert if borrower collateral token balance < seizeTokens */\n        if (cTokenCollateral.balanceOf(borrower) < seizeTokens) revert LiquidateSizeTooMuch();\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        if (address(cTokenCollateral) == address(this)) {\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\n        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            revert LiquidateSeizeComptrollerRejection(allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            revert LiquidateSeizeLiquidatorIsBorrower();\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        uint protocolSeizeTokens = FixedMath.mul_(seizeTokens, FixedMath.Exp.wrap(protocolSeizeShareMantissa));\n        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n        FixedMath.Exp exchangeRate = FixedMath.Exp.wrap(exchangeRateStoredInternal());\n        uint protocolSeizeAmount = FixedMath.mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n        uint totalReservesNew = totalReserves + protocolSeizeAmount;\n\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the calculated values into storage */\n        totalReserves = totalReservesNew;\n        totalSupply = totalSupply - protocolSeizeTokens;\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n    }\n\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            revert SetPendingAdminOwnerCheck();\n        }\n\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin);\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        return NO_ERROR;\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() override external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || pendingAdmin == address(0)) {\n            revert AcceptAdminPendingAdminCheck();\n        }\n\n        emit NewAdmin(admin, pendingAdmin);\n        emit NewPendingAdmin(pendingAdmin, payable(address(0)));\n     \n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = payable(address(0));\n\n        return NO_ERROR;\n    }\n\n    /**\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            revert SetComptrollerOwnerCheck();\n        }\n\n        // Ensure invoke comptroller.isComptroller() returns true\n        if(!newComptroller.isComptroller()) revert NotComptroller();\n\n        emit NewComptroller(comptroller, newComptroller);\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        return NO_ERROR;\n    }\n\n    /**\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\n        accrueInterest();\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            revert SetReserveFactorAdminCheck();\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            revert SetReserveFactorBoundsCheck();\n        }\n\n        emit NewReserveFactor(reserveFactorMantissa, newReserveFactorMantissa);\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\n        accrueInterest();\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            revert ReduceReservesCashNotAvailable();\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            revert ReduceReservesCashValidation();\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReserves = totalReserves - reduceAmount;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(admin, reduceAmount);\n\n        emit ReservesReduced(admin, reduceAmount, totalReserves);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\n        accrueInterest();\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            revert SetInterestRateModelOwnerCheck();\n        }\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        if (!newInterestRateModel.isInterestRateModel()) revert InvalidContractAddress();\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(interestRateModel, newInterestRateModel);\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n   \n        return NO_ERROR;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() virtual internal view returns (uint);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) virtual internal;\n\n    function isNativeToken() external pure virtual returns (bool) {\n        return false;\n    }\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract ComptrollerErrorReporter {\n    error IllegalArgument();\n    error PriceError();\n    error Unauthorized();\n    error MarketNotListed();\n    error ExitMarketBalanceOwned();\n    error MintPaused();\n    error RedeemTokensZero();\n    error BorrowPaused();\n    error SenderNotCToken();\n    error BorrowCapReached();\n    error RepayTooMuch();\n    error SeizePaused();\n    error TransferPaused();\n    error MarketAlreadyListed();\n    error InvalidBlockNumber();\n    error InvalidCollaternalFactor();\n    error ExitMarketFailed(uint);\n    enum Error {\n        NO_ERROR,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        MARKET_NOT_LISTED,\n        PRICE_ERROR,\n        TOO_MUCH_REPAY\n    }\n}\n\ncontract TokenErrorReporter {\n    uint public constant NO_ERROR = 0; // support legacy return codes\n\n    error TransferComptrollerRejection(uint256 errorCode);\n    error TransferNotAllowed();\n    error TransferNotEnough();\n    error TransferTooMuch();\n\n    error MintComptrollerRejection(uint256 errorCode);\n    error MintFreshnessCheck();\n\n    error RedeemComptrollerRejection(uint256 errorCode);\n    error RedeemFreshnessCheck();\n    error RedeemTransferOutNotPossible();\n\n    error BorrowComptrollerRejection(uint256 errorCode);\n    error BorrowFreshnessCheck();\n    error BorrowCashNotAvailable();\n\n    error RepayBorrowComptrollerRejection(uint256 errorCode);\n    error RepayBorrowFreshnessCheck();\n\n    error LiquidateComptrollerRejection(uint256 errorCode);\n    error LiquidateFreshnessCheck();\n    error LiquidateCollateralFreshnessCheck();\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\n    error LiquidateLiquidatorIsBorrower();\n    error LiquidateCloseAmountIsZero();\n    error LiquidateCloseAmountIsUintMax();\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\n\n    error LiquidateSeizeComptrollerRejection(uint256 errorCode);\n    error LiquidateSeizeLiquidatorIsBorrower();\n\n    error AcceptAdminPendingAdminCheck();\n\n    error SetComptrollerOwnerCheck();\n    error SetPendingAdminOwnerCheck();\n\n    error SetReserveFactorAdminCheck();\n    error SetReserveFactorFreshCheck();\n    error SetReserveFactorBoundsCheck();\n\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\n\n    error ReduceReservesAdminCheck();\n    error ReduceReservesFreshCheck();\n    error ReduceReservesCashNotAvailable();\n    error ReduceReservesCashValidation();\n\n    error SetInterestRateModelOwnerCheck();\n    error SetInterestRateModelFreshCheck();\n\n    error InitialExchangeRateCannotBeZero();\n    error MarketAlreadyInitialized();\n    error Unauthorized();\n    error BorrowRateTooHigh();\n    error RedeemTokensInOrRedeemAmountInShouldBeZero();\n    error LiquidateSizeTooMuch();\n    error NotComptroller();\n    error InvalidContractAddress();\n}\n"
    },
    "contracts/FixedMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\nlibrary FixedMath {\n    error InvalidNumber(uint);\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    type Exp is uint;\n \n    type Double is uint;\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return Exp.unwrap(exp) / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp a, uint scalar) pure internal returns (uint) {\n        Exp product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp left, Exp right) pure internal returns (bool) {\n        return Exp.unwrap(left) < Exp.unwrap(right);\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp left, Exp right) pure internal returns (bool) {\n        return Exp.unwrap(left) <= Exp.unwrap(right);\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp left, Exp right) pure internal returns (bool) {\n        return Exp.unwrap(left) > Exp.unwrap(right);\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp value) pure internal returns (bool) {\n        return Exp.unwrap(value) == 0;\n    }\n\n    function safe224(uint n) pure internal returns (uint224) {\n        if (n >= 2**224) revert InvalidNumber(n);\n        return uint224(n);\n    }\n\n    function safe32(uint n) pure internal returns (uint32) {\n        if (n >= 2**32) revert InvalidNumber(n);\n        return uint32(n);\n    }\n\n    function add_(Exp a, Exp b) pure internal returns (Exp) {\n        return Exp.wrap(add_(Exp.unwrap(a), Exp.unwrap(b)));\n    }\n\n    function add_(Double a, Double b) pure internal returns (Double) {\n        return Double.wrap(add_(Double.unwrap(a), Double.unwrap(b)));\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return a + b;\n    }\n\n    function sub_(Exp a, Exp b) pure internal returns (Exp) {\n        return Exp.wrap(sub_(Exp.unwrap(a), Exp.unwrap(b)));\n    }\n\n    function sub_(Double a, Double b) pure internal returns (Double) {\n        return Double.wrap(sub_(Double.unwrap(a), Double.unwrap(b)));\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return a - b;\n    }\n\n    function mul_(Exp a, Exp b) pure internal returns (Exp) {\n        return Exp.wrap(mul_(Exp.unwrap(a), Exp.unwrap(b)) / expScale);\n    }\n\n    function mul_(Exp a, uint b) pure internal returns (Exp) {\n        return Exp.wrap(mul_(Exp.unwrap(a), b));\n    }\n\n    function mul_(uint a, Exp b) pure internal returns (uint) {\n        return mul_(a, Exp.unwrap(b)) / expScale;\n    }\n\n    function mul_(Double a, Double b) pure internal returns (Double) {\n        return Double.wrap(mul_(Double.unwrap(a), Double.unwrap(b)) / doubleScale);\n    }\n\n    function mul_(Double a, uint b) pure internal returns (Double) {\n        return Double.wrap(mul_(Double.unwrap(a), b));\n    }\n\n    function mul_(uint a, Double b) pure internal returns (uint) {\n        return mul_(a, Double.unwrap(b)) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return a * b;\n    }\n\n    function div_(Exp a, Exp b) pure internal returns (Exp) {\n        return Exp.wrap(div_(mul_(Exp.unwrap(a), expScale), Exp.unwrap(b)));\n    }\n\n    function div_(Exp a, uint b) pure internal returns (Exp) {\n        return Exp.wrap(div_(Exp.unwrap(a), b));\n    }\n\n    function div_(uint a, Exp b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), Exp.unwrap(b));\n    }\n\n    function div_(Double a, Double b) pure internal returns (Double) {\n        return Double.wrap(div_(mul_(Double.unwrap(a), doubleScale), Double.unwrap(b)));\n    }\n\n    function div_(Double a, uint b) pure internal returns (Double) {\n        return Double.wrap(div_(Double.unwrap(a), b));\n    }\n\n    function div_(uint a, Double b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), Double.unwrap(b));\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double) {\n        return Double.wrap(div_(mul_(a, doubleScale), b));\n    }\n}\n"
    },
    "contracts/Interfaces/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ISmartAccountFactory.sol\";\n\nabstract contract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) virtual external;\n    function exitMarket(address cToken) virtual external;\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) virtual external returns (uint);\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) virtual external returns (uint);\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint repayAmount) virtual external view returns (uint, uint);\n    \n    function isValidSmartAccount(address account) virtual external returns (bool);\n}\n"
    },
    "contracts/Interfaces/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"../ErrorReporter.sol\";\n\ncontract CTokenStorage {\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    // Maximum borrow rate that can ever be applied (.0005% / block)\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    // Maximum fraction of interest that can be set aside for reserves\n    uint internal constant reserveFactorMaxMantissa = 1e18;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address payable public pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint public totalSupply;\n\n    // Official record of token balances for each account\n    mapping (address => uint) internal accountTokens;\n\n    // Approved token transfer amounts on behalf of others\n    mapping (address => mapping (address => uint)) internal transferAllowances;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    // Mapping of account addresses to outstanding borrow balances\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Share of seized collateral that is added to reserves\n     */\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) virtual external returns (bool);\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\n    function approve(address spender, uint amount) virtual external returns (bool);\n    function allowance(address owner, address spender) virtual external view returns (uint);\n    function balanceOf(address owner) virtual external view returns (uint);\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\n    function borrowRatePerBlock() virtual external view returns (uint);\n    function supplyRatePerBlock() virtual external view returns (uint);\n    function totalBorrowsCurrent() virtual external returns (uint);\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\n    function borrowBalanceStored(address account) virtual external view returns (uint);\n    function exchangeRateCurrent() virtual external returns (uint);\n    function exchangeRateStored() virtual external view returns (uint);\n    function getCash() virtual external view returns (uint);\n    function accrueInterest() virtual external returns (uint);\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\n\n\n    /*** Admin Functions ***/\n\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\n    function _acceptAdmin() virtual external returns (uint);\n    function _setComptroller(ComptrollerInterface newComptroller) virtual external returns (uint);\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) virtual external returns (uint);\n    function redeem(uint redeemTokens) virtual external returns (uint);\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\n    function borrow(uint borrowAmount) virtual external returns (uint);\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\n    function sweepToken(EIP20NonStandardInterface token) virtual external;\n\n\n    /*** Admin Functions ***/\n}\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual external;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) virtual external;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() virtual external;\n}\n"
    },
    "contracts/Interfaces/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return The supply of tokens\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return success Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/Interfaces/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return success Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/Interfaces/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\nabstract contract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/ISmartAccount.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ninterface ISmartAccount {\n    function getNonStandardCollateralAssetValue() external view returns (uint);\n    function withdraw(address token, uint amount, address to) external;\n    function liquidate(address borrower, address liquidator) external;\n}"
    },
    "contracts/Interfaces/ISmartAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ninterface ISmartAccountFactory {\n    function isValidSmartAccount(address account) external view returns (bool);\n}"
    },
    "contracts/Interfaces/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../CToken.sol\";\n\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\n}\n"
    },
    "contracts/RewardsPool.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Comptroller.sol\";\nimport \"./CToken.sol\";\nimport \"./FixedMath.sol\";\nimport \"./Interfaces/EIP20Interface.sol\";\n\ncontract RewardsPool is Ownable {\n    error IllegalArgument();\n    error MarketNotListed();\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierRewards(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerRewards(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when a new borrow-side COMP speed is calculated for a market\n    event RewardsBorrowSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new supply-side COMP speed is calculated for a market\n    event RewardsSupplySpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    struct RewardsMarketState {\n        // The market's last updated compBorrowIndex or compSupplyIndex\n        uint224 index;\n\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice The initial COMP index for a market\n    uint224 public constant rewardsInitialIndex = 1e36;\n\n    EIP20Interface public rewardsToken;\n\n    Comptroller public comptroller;\n\n    /// @notice The portion of compRate that each market currently receives\n    mapping(address => uint) public rewardsSpeeds;\n\n    /// @notice The COMP market supply state for each market\n    mapping(address => RewardsMarketState) public rewardsSupplyState;\n\n    /// @notice The COMP market borrow state for each market\n    mapping(address => RewardsMarketState) public rewardsBorrowState;\n\n    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    mapping(address => uint) public rewardsAccrued;\n\n    constructor(EIP20Interface rewardsToken_, Comptroller comptroller_) {\n        rewardsToken = rewardsToken_;\n        comptroller = comptroller_;\n    }\n\n    /**\n     * @notice Set COMP borrow and supply speeds for the specified markets.\n     * @param cTokens The markets whose COMP speed to update.\n     * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n     * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n     */\n    function _setRewardsSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) external {\n        // if (!adminOrInitializing()) revert Unauthorized();\n\n        uint numTokens = cTokens.length;\n        if (numTokens != supplySpeeds.length || numTokens != borrowSpeeds.length) revert IllegalArgument();\n\n        for (uint i = 0; i < numTokens; ++i) {\n            _addRewardsMarketInternal(address(cTokens[i]));\n            setRewardsSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    function _addRewardsMarketInternal(address cToken) internal {\n        if (rewardsSupplyState[cToken].index == 0) {\n            rewardsSupplyState[cToken] = RewardsMarketState({\n                index: rewardsInitialIndex,\n                block: FixedMath.safe32(comptroller.getBlockNumber())\n            });\n        }\n\n        if (rewardsBorrowState[cToken].index == 0) {\n            rewardsBorrowState[cToken] = RewardsMarketState({\n                index: rewardsInitialIndex,\n                block: FixedMath.safe32(comptroller.getBlockNumber())\n            });\n        }\n    }\n\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param supplySpeed New supply-side COMP speed for market\n     * @param borrowSpeed New borrow-side COMP speed for market\n     */\n    function setRewardsSpeedInternal(CToken cToken, uint supplySpeed, uint borrowSpeed) internal {\n        (bool isListed,,,) = comptroller.markets(address(cToken));\n        if (!isListed) revert MarketNotListed();\n\n        uint currentRewardsSpeed = rewardsSpeeds[address(cToken)];\n        uint currentSupplySpeed = currentRewardsSpeed >> 128;\n        uint currentBorrowSpeed = uint128(currentRewardsSpeed);\n\n        if (currentSupplySpeed != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. COMP accrued properly for the old speed, and\n            //  2. COMP accrued at the new speed starts after this block.\n            updateRewardsSupplyIndex(address(cToken));\n\n            // Update speed and emit event\n            // compSupplySpeeds[address(cToken)] = supplySpeed;\n            emit RewardsSupplySpeedUpdated(cToken, supplySpeed);\n        }\n\n        if (currentBorrowSpeed != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. COMP accrued properly for the old speed, and\n            //  2. COMP accrued at the new speed starts after this block.\n            FixedMath.Exp borrowIndex = FixedMath.Exp.wrap(cToken.borrowIndex());\n            updateRewardsBorrowIndex(address(cToken), borrowIndex);\n\n            // Update speed and emit event\n            // compBorrowSpeeds[address(cToken)] = borrowSpeed;\n            emit RewardsBorrowSpeedUpdated(cToken, borrowSpeed);\n        }\n        uint newRewardsSpeed = uint256(supplySpeed << 128) + borrowSpeed;\n        rewardsSpeeds[address(cToken)] = newRewardsSpeed;\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n    function updateRewardsSupplyIndex(address cToken) public {\n        RewardsMarketState storage supplyState = rewardsSupplyState[cToken];\n        uint compSpeed = rewardsSpeeds[cToken];\n        // use first 128 bit as supplySpeed\n        uint supplySpeed = compSpeed >> 128;\n        uint32 blockNumber = uint32(comptroller.getBlockNumber());\n        uint deltaBlocks = FixedMath.sub_(uint(blockNumber), uint(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint supplyTokens = CToken(cToken).totalSupply();\n            uint compAccrued = FixedMath.mul_(deltaBlocks, supplySpeed);\n            FixedMath.Double ratio = supplyTokens > 0 ? FixedMath.fraction(compAccrued, supplyTokens) : FixedMath.Double.wrap(0);\n            supplyState.index = FixedMath.safe224(FixedMath.Double.unwrap(FixedMath.add_(FixedMath.Double.wrap(supplyState.index), ratio)));\n            supplyState.block = blockNumber;\n        } else if (deltaBlocks > 0) {\n            supplyState.block = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n    function updateRewardsBorrowIndex(address cToken, FixedMath.Exp marketBorrowIndex) public {\n        RewardsMarketState storage borrowState = rewardsBorrowState[cToken];\n        // use last 128 bit as borrowSpeed\n        uint borrowSpeed = uint128(rewardsSpeeds[cToken]);        \n        uint32 blockNumber = uint32(comptroller.getBlockNumber());\n        uint deltaBlocks = FixedMath.sub_(uint(blockNumber), uint(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint borrowAmount = FixedMath.mul_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n            uint compAccrued = FixedMath.mul_(deltaBlocks, borrowSpeed);\n            FixedMath.Double ratio = borrowAmount > 0 ? FixedMath.fraction(compAccrued, borrowAmount) : FixedMath.Double.wrap(0);\n            borrowState.index = FixedMath.safe224(FixedMath.Double.unwrap(FixedMath.add_(FixedMath.Double.wrap(borrowState.index), ratio)));\n            borrowState.block = blockNumber;\n        } else if (deltaBlocks > 0) {\n            borrowState.block = blockNumber;\n        }\n    }\n    \n    /**\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n    function distributeSupplierRewards(address cToken, address supplier) internal {\n        // TODO: Don't distribute supplier COMP if the user is not in the supplier market.\n        // This check should be as gas efficient as possible as distributeSupplierRewards is called in many places.\n        // - We really don't want to call an external contract as that's quite expensive.\n\n        RewardsMarketState storage supplyState = rewardsSupplyState[cToken];\n        uint supplyIndex = supplyState.index;\n        uint supplierIndex = compSupplierIndex[cToken][supplier];\n\n        // Update supplier's index to the current index since we are distributing accrued COMP\n        compSupplierIndex[cToken][supplier] = supplyIndex;\n\n        if (supplierIndex == 0 && supplyIndex >= rewardsInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with COMP accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = rewardsInitialIndex;\n        }\n\n        // Calculate change in the cumulative sum of the COMP per cToken accrued\n        FixedMath.Double deltaIndex = FixedMath.Double.wrap(FixedMath.sub_(supplyIndex, supplierIndex));\n\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\n\n        // Calculate COMP accrued: cTokenAmount * accruedPerCToken\n        uint supplierDelta = FixedMath.mul_(supplierTokens, deltaIndex);\n\n        uint supplierAccrued = FixedMath.add_(rewardsAccrued[supplier], supplierDelta);\n\n        rewardsAccrued[supplier] = supplierAccrued;\n\n        emit DistributedSupplierRewards(CToken(cToken), supplier, supplierDelta, supplyIndex);\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n    function distributeBorrowerRewards(address cToken, address borrower, FixedMath.Exp marketBorrowIndex) internal {\n        // TODO: Don't distribute supplier COMP if the user is not in the borrower market.\n        // This check should be as gas efficient as possible as distributeBorrowerRewards is called in many places.\n        // - We really don't want to call an external contract as that's quite expensive.\n\n         RewardsMarketState storage borrowState = rewardsBorrowState[cToken];\n        uint borrowIndex = borrowState.index;\n        uint borrowerIndex = compBorrowerIndex[cToken][borrower];\n\n        // Update borrowers's index to the current index since we are distributing accrued COMP\n        compBorrowerIndex[cToken][borrower] = borrowIndex;\n\n        if (borrowerIndex == 0 && borrowIndex >= rewardsInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with COMP accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = rewardsInitialIndex;\n        }\n\n        // Calculate change in the cumulative sum of the COMP per borrowed unit accrued\n        FixedMath.Double deltaIndex = FixedMath.Double.wrap(FixedMath.sub_(borrowIndex, borrowerIndex));\n\n        uint borrowerAmount = FixedMath.div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n        // Calculate COMP accrued: cTokenAmount * accruedPerBorrowedUnit\n        uint borrowerDelta = FixedMath.mul_(borrowerAmount, deltaIndex);\n\n        uint borrowerAccrued = FixedMath.add_(rewardsAccrued[borrower], borrowerDelta);\n        rewardsAccrued[borrower] = borrowerAccrued;\n\n        emit DistributedBorrowerRewards(CToken(cToken), borrower, borrowerDelta, borrowIndex);\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n    function claimRewards(address holder) public {\n        return claimRewards(holder, comptroller.getAllMarkets());\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n    function claimRewards(address holder, CToken[] memory cTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimRewards(holders, cTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n    function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n        for (uint i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            (bool isListed,,,) = comptroller.markets(address(cToken));\n            require(isListed, \"market must be listed\");\n            if (borrowers == true) {\n                FixedMath.Exp borrowIndex = FixedMath.Exp.wrap(cToken.borrowIndex());\n                updateRewardsBorrowIndex(address(cToken), borrowIndex);\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeBorrowerRewards(address(cToken), holders[j], borrowIndex);\n                }\n            }\n            if (suppliers == true) {\n                updateRewardsSupplyIndex(address(cToken));\n                for (uint j = 0; j < holders.length; j++) {\n                    distributeSupplierRewards(address(cToken), holders[j]);\n                }\n            }\n        }\n\n        for (uint j = 0; j < holders.length; j++) {\n            rewardsAccrued[holders[j]] = grantRewardsInternal(holders[j], rewardsAccrued[holders[j]]);\n        }\n    }\n\n    /**\n     * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n    function grantRewardsInternal(address user, uint amount) internal returns (uint) {\n        // EIP20Interface comp = EIP20Interface(rewardsToken);\n        uint compRemaining = rewardsToken.balanceOf(address(this));\n        if (amount > 0 && amount <= compRemaining) {\n            rewardsToken.transfer(user, amount);\n            return 0;\n        }\n        return amount;\n    }\n}"
    },
    "contracts/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is changed\n      */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n      */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n      * @notice Emitted when pendingAdmin is changed\n      */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n      */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n        if (msg.sender != admin) revert Unauthorized();\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n    * @dev Admin function for new implementation to accept it's role as implementation\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n    */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            revert Unauthorized();\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) revert Unauthorized();\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) revert Unauthorized();\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}